# 渲染策略
* 客户端渲染(CSR)
在浏览器中运行，并输出DOM元素。
* 服务端渲染(SSR)
在Node环境中运行，将同样的组建渲染为字符串并发送给浏览器
* 同构渲染
将客户端和服务端两者结合, 同样一套代码即可以在服务端运行、也可以在客户端运行。

- SSR对SEO更加友好
- SSR不会产生白屏问题；CSR有白屏问题
- SSR消耗更多服务端资源，在服务端完成页面渲染；CSR减少服务端资源消耗
- CSR相对SSR具有更好的用户体验

## 同构渲染
分为首次渲染(即首次渲染或刷新页面)、非首次渲染。

首次渲染与SSR工作流程一致。
首次访问(刷新页面)时，整个页面的内容是在服务端完成渲染的，浏览器最终得到的是渲染好的HTML页面。但此刻该页面是纯静态的，无法进行交互、脚本未加载执行。
同构渲染会包含当前页面所需要的初始化数据，即服务器通过API请求的数据会被序列化为字符串、并拼接到静态的HTML字符串中，最后一并发送给浏览器。

在接收到首次渲染的静态HTML页面，接下来浏览器会解析并渲染该页面。当js资源加载完成后进行**激活操作**，即hydration
- 在当前页面已经渲染的DOM元素 以及 组建所渲染的虚拟DOM之间建立联系。
- 从HTML页面中提取 由服务端序列化后发送过来的数据，用以初始化整个应用程序。

激活完成后，整个应用程序完全被接管为CSR应用程序了。

## 将虚拟DOM渲染为HTML字符

在渲染过程中需要考虑以下边界条件
1. 在渲染标签类型的虚拟节点时，需要考虑该节点是否为自闭合标签(void element)。
2. 考虑属性名称的是否合法，对属性值进行HTML转义。
3. 子节点类型众多，可能是任意类型的虚拟节点(Fragment/组件/函数式组建/文本等)
4. 标签的文本子节点需要进行HTML转义

* 处理HTML属性
- boolean属性, 存在为true、否则为false
- 忽略仅用于组建运行时逻辑的相关属性(key仅用于虚拟DOM的Diff算法、ref仅用于实现template ref等)
- 无需考虑事件绑定

注: 处理属性值时，需要对其进行转义处理(将特殊字符转换成对应的HTML实体)。

## 将组建渲染为HTML字符串

渲染中的问题
1. 组件的不同类型
2. 组件的初始化流程

* 客户端渲染
beforeCreate -> 初始化data/props等 -> 创建组建实例 -> setup执行 -> created -> 设置render effect完成渲染

* 服务端渲染
- 只渲染应用的当前快照，不存在数据变更后重新渲染的情况。 -> 那么所有数据在服务端都无须是响应式的。
- 只需要获取组建要渲染的subTree即可，无须调用渲染器完成真实DOM的创建。 -> 忽略 "设置render effect" 这个步骤。

## 客户端激活原理

在同构渲染中, 组件代码会在服务端和客户端分别执行一次。

在服务端，组件被渲染为静态的HTML字符串，然后发送给浏览器、浏览器再把这段静态的HTML渲染出来。此时页面中已经存在对应的DOM元素，同时该组件还会被打包到一个js文件中，并在浏览器中下载、解释和执行。

当组件代码在浏览器中执行时，不会再次创建DOM元素；但任然需要做两件事
1. 在页面中的DOM元素与虚拟节点对象之间建立联系。
2. 为页面中的DOM元素添加事件绑定。

一个虚拟节点被挂载后，为了保证更新程序能正确运行、需要通过该虚拟节点的vnode.el属性存储真实DOM对象的引用。
