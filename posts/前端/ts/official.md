# 有效链接
[通用js库声明文件](https://github.com/DefinitelyTyped/DefinitelyTyped)
[metadata](https://rbuckton.github.io/reflect-metadata/#introduction)

## 装饰器
使用`@expression`这种形式，expression求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。
```ts
function f(target) {}
@f // 求值, 直接返回函数

function f() {
  return (target) => {}
}
@f() // 求值, 先执行再返回函数

// 求值是一个动作, 必须返回一个函数、用于运行时调用
```


* 装饰器组合
多个装饰器同时应用到一个声明上
```ts
// 同一行
@f @g x

// 多行
@f
@g
x

// 1. 每个装饰器的表达式都是从上到下计算的。
// 2. 然后将结果作为函数从下到上调用。
```

* 应用装饰器到类内部的各种声明，有一个明确定义的顺序
1. 参数装饰器，然后是方法、访问器或属性装饰器应用于每个实例成员;
2. 参数装饰器，然后是方法、访问器或属性装饰器应用于每个静态成员;
3. 参数装饰器应用于构造函数。
4. 类装饰器应用于类。

注： 多个实例/静态成员按类中顺序, 从上往下执行。

* 类装饰器
表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数。

如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明。
> 注: 如果要返回一个新的构造函数，必须注意处理好原来的原型链。在运行时的装饰器调用逻辑中不会做这些。

* 方法装饰器
应用到方法的属性描述符上，可以用来监视，修改或者替换方法定义。

表达式会在运行时当作函数被调用，具有以下三个参数：
1. 对于静态成员来说是类的构造函数(类本身)，对于实例成员是类的原型对象。
2. 成员的名字。
3. 成员的属性描述符。

如果方法装饰器返回一个值，它会被用作方法的属性描述符。

* 访问器装饰器
应用于访问器的 属性描述符并且可以用来监视，修改或替换一个访问器的定义。
注：不允许同时装饰一个成员的get和set访问器。

访问器装饰器表达式会在运行时当作函数被调用，具有以下三个参数：
1. 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。
2. 成员的名字。
3. 成员的属性描述符。

如果访问器装饰器返回一个值，它会被用作方法的属性描述符。

* 属性装饰器
表达式会在运行时当作函数被调用，具有以下两个参数：
1. 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。
2. 成员的名字。

注：属性描述符不会作为参数提供。 因此，属性描述符只能用来监视类中是否声明了某个名字的属性。

返回值被忽略。

* 参数装饰器
应用于类构造函数或方法声明的函数。

参数装饰器的表达式将在运行时作为函数调用，具有以下三个参数：
1. 静态成员的类的构造函数，或实例成员的类的原型对象。
2. 成员的名字。
3. 函数参数列表中参数的顺序索引。

返回值被忽略。

注：参数装饰器只能用于观察方法上声明了参数。


```ts
1. 类装饰器 最后 求值、执行
2. 类中属性、方法(无参数修饰器)按顺序 求值、执行
3. 类中方法(有参数修饰器)
  3.1 方法装饰器先求值、参数修饰器后求值
  3.2 参数修饰器先执行、方法装饰器后执行
  3.3 多个参数修饰器, 按从右往左的顺序
```