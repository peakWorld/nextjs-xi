## 加载 .obj文件
没有提供任何场景图, 所有的数据都需要加载到一个巨大的网格中。几何信息由.obj文件提供，材质信息由.mtl文件定义；
[mtl相关注释](public/t_/windmill_2/windmill-fixed.mtl)

* 修复材质单面问题

* 放大近看、东西正在变成块状
- 法线贴图通常是紫色的，而凹凸贴图则是黑白的。法线贴图表示表面的方向，而凹凸贴图则表示表面的高度。

* 模型太大, 尝试自动设置相机的参数

* 常见问题
- 需要知道大小。最合适的做法是自己制作模型或下载模型，加载到一些3D软件中，查看它们的大小，并在需要时进行调整。
- 方向错误。Three.js一般是以Y为上。模型加载到最喜欢的建模工具里旋转物体至合适的位置。
- 没有.mtl文件、错误的材质或不兼容的参数。
- 纹理过大。

## 加载 .gltf文件
是第一个真正意义上的传输格式。
1. 体积小，适合用于传输。大数据量的数据被存为二进制格式，能零处理的传入GPU。
2. 易于被渲染。对渲染不重要的那部分数据大都被删除了。

理想情况下，场景将由一个没有位置、旋转或缩放的“根”节点组成。
在运行时，可以将所有子节点从该根中拉出，并将它们作为场景本身的父级。

## 背景与天空盒
* 背景
方式一: 父元素背景图片, canvas设置`alpha: true`
方式二: 将纹理设置为场景的背景`scene.background = texture`

* 天空图
方式一: 制作一个立方体，应用纹理，绘制在它的内部。
方式二: 使用立方体贴图. 一种特殊的纹理，有6个立方体面，不使用标准的纹理坐标，使用从中心指向外部的方向来决定绘制的颜色。
- [生成cube-map](https://matheowis.github.io/HDRI-to-CubeMap)
方式三: 使用等距矩形贴图。这是被360全景相机拍摄的一种特殊类型的图片。

## 透明
* 3d物体的一般性绘制方式: 对于每个几何体，一次绘制一个三角形。 当三角形的一个像素在被绘制的时候，会记录两件事情。一是像素的颜色，二是像素的深度。当下一个三角形被绘制的时候，对于深度大于先前被记录的深度的像素，将不会被绘制。
- 对于不透明的物体工作得很好，对于透明的物体不能正常工作。
- 方案一: 将透明的物体进行排序，排在后面的物体比排在前面的物体先绘制(threejs默认方式)。
- 方案二: 将每一个立方体添加到场景中两次。一次带有仅绘制后面三角形的材质，另外一次带有仅绘制前面三角形的材质。

* 相交物体
- 将每个平面分割为2个，这样它们实际上就没有了交集。然后threejs进行排序绘制。
- 只能用于像2个不会改变相交位置的简单物体

* 设置alpha测试
指像素的alpha值低于某个水平的时候，three.js就不会绘制它。如果根本就不绘制某个像素，那么上面提到的深度问题就消失了。
- 对于具有相对尖锐边缘的纹理，这种方式工作得很好。

注:
1. 一辆车。汽车通常会在4个面上有挡风玻璃。如果想要避免上面提到的排序问题，不得不将每一扇窗户成为它自己的物体，以便three.js可以**排序这些窗户并以正确的顺序绘制**它们。
2. 如果在制作一些植物或是草地，**alpha测试**是常用的解决方案。


## 多个画布，多个场景
1. 浏览器限制了WebGL上下文(WebGL contexts)的数量。通常浏览器将其限制为 8 个，一旦超出这个数量，最先创建的WebGL上下文就会被自动弃用。
2. 无法在不同的WebGL上下文中共享资源。

* 基本方法[case4_5]
用一张Canvas在整个背景中填充视口，并利用一些其他元素来代表每个“虚拟画布”(virtual canvas)，即只在一张Canvas中加载一个Renderer，并为每个virtual canvas创建一个场景(Scene)。
- 解决了资源共享问题，且不会引发WebGL上下文数量限制问题。
- 需要在背景设置一个Canvas。

> Renderer.setScissorTest( boolean : Boolean ) // 启用或禁用剪裁检测. 若启用，则只有在所定义的裁剪区域内的像素才会受之后的渲染器影响。
> Renderer.setScissor (x: Integer, y: Integer, width: Integer, height: Integer) //将剪裁区域设为(x, y)到(x + width, y + height)
> Renderer.setViewport (x : Integer, y: Integer, width: Integer, height: Integer) //将视口大小设置为(x, y)到 (x + width, y + height).

- 同步滚动[case4_5/common]
如果Scenes过于复杂、或者由于其他原因需要更长时间渲染，那么画布中Scenes渲染的位置总是会落后于页面的其他元素，如页面滚动时会出现明显的滞后。

* 其他方法[case4_5/outside]
渲染到屏幕外的画布上，并将结果复制到对应的2D画布上。
- 优点是对如何组合每个独立区域没有限制，因此只需正常编写HTML即可。
- 缺点就是速度较慢，因为每个区域都必须进行复制

注: 收集多个场景的特有元素于某个对象中, 然后在render函数逐个处理每个场景

## 拾取
推断用户点击或触碰了哪个对象的过程。

* 射线追踪法[case4_6]
从鼠标处发射一条射线，穿透场景的视椎体，通过计算，找出视锥体中哪些对象与射线相交。
> 获取鼠标的屏幕坐标.
> 其次，对其应用摄像机的投影和方向的矩阵变换，得到其在世界空间的坐标。
> 然后，计算出一条射线，从视锥体的近端平面射向远端平面。
> 再然后，对于场景中每一个对象的每一个三角，检查其是否与射线相交。

注: 假设场景中有1000个对象，每个对象有1000个三角，那么就需要检查一百万个三角。
> 优化，先检查对象的包围球或包围盒是否与射线相交，包围球或包围盒是指包含整个对象的球体或者立方体，如果射线未相交，就不需要检查组成该对象的三角们了。

问题
> 基于CPU运算的Javascript遍历每一个对象,检查其包围盒或包围球是否与射线相交，如果相交，必须遍历组成该对象的每一个三角，检查是否与射线相交。例：当对象由大量的三角组成时，这个过程会有些慢。
> 无法处理一些奇怪的着色器或者位移。例：不能对有皮肤的对象使用这种方式。
> 无法处理透明的孔洞。
因为JavaScript无法通过简单的查看纹理和材质，就推测出对象是否存在一部分是透明的或者不透明。

* 基于GPU的拾取方法[case4_6/gpu]
> 对每一个对象使用唯一的颜色进行离屏渲染。
> 然后，检查鼠标位置关联的像素的颜色。这个颜色就能告诉我们哪个对象被选中。
每个对象会被绘制两次，一次用于观看，一次用于拾取。
注: 因为拾取时只需读取1px，所以可以设置摄像机，只绘制1px，通过PerspectiveCamera.setViewOffset方法，可以告诉THREE.js计算出一个摄像机 只呈现一个大矩形的一个很小的部分。

1. 创建两个场景。一个使用正常的网格对象填充。另外一个使用“拾取材质”的网格对象填充。
2. 对于在主场景中的每一个立方体，在'拾取场景'中，同样的位置，创建一个与原立方体相似的，相关联的“可拾取立方体”、且设置唯一颜色。

## 后期处理
指应用到2d图像上的某种特效或者是滤镜。[case4_7]
ThreeJs工作方式:
1. 创建EffectComposer然后增加一些Pass对象。
2. 每一个Pass阶段都可以增加一些后置处理特效，添加小插图，模糊，添加光晕，添加噪点，调整色相，饱和度，对比度等等。
3. 最终把效果渲染到canvas。

* Pass
- enabled 是否使用这个pass
- needsSwap 完成这个pass后是否交换rtA和rtB
- clear 在渲染这个pass之前是否需要清除
- renderToScreen 是否将当前的内容渲染到画布上。通常来说需要在最后添加的pass设置这一项为true

* ShaderPass[case4_7/shader]
一个对象，该对象的信息定义了顶点着色器，片段着色器和默认输入。将处理设置要读取的纹理以获取上一遍的结果以及要渲染到EffectComposers渲染目标之一或画布上的位置。

## 后处理 3DLUT(LUT代表查找表)[case4_8]
工作原理是制作一个颜色立方体。然后使用源图像的颜色对立方体进行索引。对于原始图像中的每个像素，根据原始像素的红色、绿色和蓝色在立方体中查找位置。

注: 无论纹理的尺寸如何，纹理都会从0.0到1.0的值进行引用。
假设: 一个8x8x8的立方体，用0,0,0角填充纯黑色，相反的1,1,1角纯白色。1,0,0 是纯红色。0,1,0为纯绿色，0,0,1为蓝色。
[](./assets/3dlut-rgb.svg)
所有方格填充颜色, 这是一个3DLUT。此时产生与输入完全相同的输出。如果查找一种颜色，就会得到相同的颜色。

- 如果将立方体更改为琥珀色，那么当查找颜色时，会在3D查找表中查找相同的位置，但会产生不同的输出。

通过提供不同的查找表来使用这种技术，可以应用各种效果。[case4_8/3dlut]
基本上任何可以仅基于单一颜色输入计算的效果。这些效果包括调整色调、对比度、饱和度、色偏、色调、亮度、曝光、级别、曲线、色调分离、阴影、高光等。更好的是，它们可以全部组合成一个查找表。

## Shadertoy[case4_9]
https://www.shadertoy.com/

* 动态纹理
[case1_11] 利用WebGLRenderTarget技术生成, 时时更新纹理图片
[case4_9/texture] 通过GLSL生成, 根据时间动态更新像素颜色

## 对齐HTML元素到3D对象

* 在3D场景中显示一些文本
- 使用3D文本
图元TextGeometry可以生成3D文本。这对飞行类的Logo很有效，但对统计、信息、标记类不是很合适。

- 使用带2D文本的纹理图
使用Canvas作为物体的纹理。向Canvas中绘制文字并且以Billboard的方式展示。这的优点是文本已被集成到3D场景中，像3D场景中的计算机终端，这可能是比较完美的。

- 使用HTML元素并定位它们以匹配3D场景
可以使用所有的HTML能力。HTML中可以有多个元素，可以通过CSS设置样式，它也可以被用户选中因为它就是实际的文本内容。
注: 根据世界坐标中的 v.xy计算对应的屏幕坐标, v.z设置相应的zIndex; 再绝对定位在屏幕中。

### 使用HTML元素 [case4_10]
* 问题一: 旋转对象，一旦它们重叠了，那么它们对应的Label可能也会重叠。
> 实现方案 => 获取对象在屏幕上的位置，然后调用RayCaster来告诉和哪些对象相交了;如果对象不是相交结果的第一个，说明它不在最前面。只展示最前面对象label。 **拾取很慢。** [case4_10/overlap]
> 优化方案 => 基于GPU的拾取方案。

* 问题二: 缩小了视野，物体移出了视锥体范围，Label还是在显示。
> 失败方案 => 检查tempV.z 判断此对象的原点是否在截锥体之外。因为在标准化坐标包含一个z值，从 -1(相机视锥体的near值) 开始到 +1(相机视锥体的far值)结束。在此只检查对象的原点，而对于一个大对象，它的原点可能会超出视锥体，但是对象仍然有一部分处于可视范围内。[case4_10/overlap]
> 实现方案 => 检查对象本身是否在视锥体中。**检查很慢。** [case4_10/cone]

注: 标准化屏幕坐标 => x=-1 表示在最左侧；y=-1 表示在最底部; z=-1 表示在屏幕外侧。
注: camera.matrixWorldInverse 相机模型矩阵的逆矩阵 就是 物体的视图矩阵; 例如: 相机向右移动, 可以看作物体向左移动

* 问题三: Label显示顺序, Label文案过长、后面对象(未重叠)的label展示在前面。
> 实现方案 => 给每一个元素设置 zIndex。投影生成的位置有一个z值, -1表示最前面, 1表示最后面。 而zIndex 却是一个整型，并且含义相反，zIndex越大表示越靠前，所以下面的代码可能有用。

### 绘制地球仪[case4_10/globe]
* 出现了背面的Label [case4_10/backlabels] => [TODO, 数学公式没看懂]
> 检查特定的国家是否远离我们。因为Label的位置围绕的是一个球体。事实上使用的是一个半径1.0的单位球体，这意味着这些位置已经是单位向量，数学计算上比较简单。

* Label真的太多了  [case4_10/morelabels]
> 只显示大国的Label，加载的数据包含一个国家包含经纬度的最大和最小值，从中可以计算出一个区域，然后用它来判断是否显示国家。

## 使用纹理索引来拾取和着色
选中一个国家并高亮

方法一: 为每个国家生成几何图形，然后 使用射线拾取。如果点击代表那个国家的网格对象，就知道对应的国家了。
> 生成了15.5m的二进制GLTF(.glb)文件、实在太多了。
- 解决方案一： 应用一些算法来降低轮廓的分辨率，但可能出现美国边界变大而加拿大边界变小的情况。
- 解决方案二： 仅使用数据压缩，比如gzip将其降至11m，这减少了30%，但是还不够。

方法二: 使用GPU拾取方案 | 调色板图形算法
> 步骤一(GPU拾取方案 选中国家)[case4_11]
- 预先生成一张国家的地图，每个国家的颜色是它在国家数组中的索引号。有两个场景。
- 背后场景 使用索引纹理绘制一个离屏全局画布，查看颜色会告诉我们用户点击了那个国家ID; 正常场景 展示物体。

> 步骤二(调色板图形算法 随机涂色国家)[case4_11/random]
- 并非以RGBA的形式给每个颜色存储8位、每个像素至少32字节的位图，他们存储位图是8位或者更少。每个像素都是一个调色板的索引值; 例如 一个像素值为3，表示“显示3号颜色值”，而定义3号颜色值的地方就叫“调色板”。
- 在`material.onBeforeCompile`中修改默认shader

> 步骤三(选中高亮)[case4_11/[case4_11/random]]
根据ID选择 调色板中指定位置的颜色。

## Canvas纹理
[教程](https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial)
* 在随机位置上绘制随机颜色的点[case4_12]
* canvas纹理[case4_12/texture]
* 常见用法是在场景中绘制文本[case4_12/text]

问题一：过度放大，标签的分辨率会降低。[case4_12/resolution]
> 增加标签的分辨率(指定标签的固定大小，然后挤压文本)
> 用一个Canvas生成多个纹理

问题二：标签并不总是面向相机。
如果使用标签作为徽标，这是一件好事；如果使用标签来放置3D游戏中玩家的名字，希望标签总是面对相机。
> 广告牌
> 使用HTML(特别是对于标签)，因为HTML标签总是在最上层

注: 渲染一帧, 确保纹理被正确初始化; 对于在渲染循环之外使用纹理时非常有用

## 广告牌

* 制作一些总是面对相机的东西[case4_13]
> Three.js提供了Sprite和SpriteMaterial来实现这个功能。

* 绘制立面[case4_13/facades]
不绘制3D对象，而是使用图片绘制2D平面化的3D对象，这通常比绘制3D对象要快。
注: 利用WebGLRenderTarget渲染某个物体，生成纹理

## 释放资源
threejs应用经常使用大量的内存。
> 一个3D模型的所有节点，可能占用1-20M内存。
> 一个模型可能会使用很多纹理，即使它们被压缩成了图片文件，也必须被展开成为未压缩的形态来使用。每个 1024 x 1024 大小的纹理会占用4-5M内存。

注: 通过在纹理、 图元和 材质对象上调用dispose方法来释放资源。

## 像素几何(类我的世界) [case4_15]

* 最大问题: 在立方体内制作了所有实际上永远看不到的面。
> 自己构建几何体，并考虑到如果有相邻的邻居，则不需要面向该邻居的面

* 问题二: 占用内存太大, 256x256x256(16M)[case4_15/voxel]
> 划分小区域32x32x32(32k), 仅在其中有东西时才创建一个区域。

* 添加纹理[case4_15/texture]

* 多区块(Cell)[case4_15/mul]
1. 按照随机方式定义一个形状, 按照这个形状生成geometry
> 创建默认区块Cell, 然后给区块中的体素随机赋值<只有v大于0才会判断面是否需要渲染>
> 根据设置的v值来判断四周是否有其他体素, 该面没有邻居则要合并此面<将坐标点合并成一个geometry>

2. 根据鼠标点击, 更新形状; 生成新的geometry
> 根据鼠标点击, 获取体素位置更新其v值, 是否为新区块
> 是, 生成新的geometry; 否, 更新原来geometry

