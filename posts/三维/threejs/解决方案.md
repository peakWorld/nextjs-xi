## 加载 .obj文件
没有提供任何场景图, 所有的数据都需要加载到一个巨大的网格中。几何信息由.obj文件提供，材质信息由.mtl文件定义；
[mtl相关注释](public/t_/windmill_2/windmill-fixed.mtl)

* 修复材质单面问题

* 放大近看、东西正在变成块状
- 法线贴图通常是紫色的，而凹凸贴图则是黑白的。法线贴图表示表面的方向，而凹凸贴图则表示表面的高度。

* 模型太大, 尝试自动设置相机的参数

* 常见问题
- 需要知道大小。最合适的做法是自己制作模型或下载模型，加载到一些3D软件中，查看它们的大小，并在需要时进行调整。
- 方向错误。Three.js一般是以Y为上。模型加载到最喜欢的建模工具里旋转物体至合适的位置。
- 没有.mtl文件、错误的材质或不兼容的参数。
- 纹理过大。

## 加载 .gltf文件
是第一个真正意义上的传输格式。
1. 体积小，适合用于传输。大数据量的数据被存为二进制格式，能零处理的传入GPU。
2. 易于被渲染。对渲染不重要的那部分数据大都被删除了。

理想情况下，场景将由一个没有位置、旋转或缩放的“根”节点组成。
在运行时，可以将所有子节点从该根中拉出，并将它们作为场景本身的父级。

## 背景与天空盒
* 背景
方式一: 父元素背景图片, canvas设置`alpha: true`
方式二: 将纹理设置为场景的背景`scene.background = texture`

* 天空图
方式一: 制作一个立方体，应用纹理，绘制在它的内部。
方式二: 使用立方体贴图. 一种特殊的纹理，有6个立方体面，不使用标准的纹理坐标，使用从中心指向外部的方向来决定绘制的颜色。
- [生成cube-map](https://matheowis.github.io/HDRI-to-CubeMap)
方式三: 使用等距矩形贴图。这是被360全景相机拍摄的一种特殊类型的图片。

## 透明
* 3d物体的一般性绘制方式: 对于每个几何体，一次绘制一个三角形。 当三角形的一个像素在被绘制的时候，会记录两件事情。一是像素的颜色，二是像素的深度。当下一个三角形被绘制的时候，对于深度大于先前被记录的深度的像素，将不会被绘制。
- 对于不透明的物体工作得很好，对于透明的物体不能正常工作。
- 方案一: 将透明的物体进行排序，排在后面的物体比排在前面的物体先绘制(threejs默认方式)。
- 方案二: 将每一个立方体添加到场景中两次。一次带有仅绘制后面三角形的材质，另外一次带有仅绘制前面三角形的材质。

* 相交物体
- 将每个平面分割为2个，这样它们实际上就没有了交集。然后threejs进行排序绘制。
- 只能用于像2个不会改变相交位置的简单物体

* 设置alpha测试
指像素的alpha值低于某个水平的时候，three.js就不会绘制它。如果根本就不绘制某个像素，那么上面提到的深度问题就消失了。
- 对于具有相对尖锐边缘的纹理，这种方式工作得很好。

注:
1. 一辆车。汽车通常会在4个面上有挡风玻璃。如果想要避免上面提到的排序问题，不得不将每一扇窗户成为它自己的物体，以便three.js可以**排序这些窗户并以正确的顺序绘制**它们。
2. 如果在制作一些植物或是草地，**alpha测试**是常用的解决方案。


## 多个画布，多个场景
1. 浏览器限制了WebGL上下文(WebGL contexts)的数量。通常浏览器将其限制为 8 个，一旦超出这个数量，最先创建的WebGL上下文就会被自动弃用。
2. 无法在不同的WebGL上下文中共享资源。

* 基本方法[case4_5]
用一张Canvas在整个背景中填充视口，并利用一些其他元素来代表每个“虚拟画布”(virtual canvas)，即只在一张Canvas中加载一个Renderer，并为每个virtual canvas创建一个场景(Scene)。
- 解决了资源共享问题，且不会引发WebGL上下文数量限制问题。
- 需要在背景设置一个Canvas。

> Renderer.setScissorTest( boolean : Boolean ) // 启用或禁用剪裁检测. 若启用，则只有在所定义的裁剪区域内的像素才会受之后的渲染器影响。
> Renderer.setScissor (x: Integer, y: Integer, width: Integer, height: Integer) //将剪裁区域设为(x, y)到(x + width, y + height)
> Renderer.setViewport (x : Integer, y: Integer, width: Integer, height: Integer) //将视口大小设置为(x, y)到 (x + width, y + height).

- 同步滚动[case4_5/common]
如果Scenes过于复杂、或者由于其他原因需要更长时间渲染，那么画布中Scenes渲染的位置总是会落后于页面的其他元素，如页面滚动时会出现明显的滞后。

* 其他方法[case4_5/outside]
渲染到屏幕外的画布上，并将结果复制到对应的2D画布上。
- 优点是对如何组合每个独立区域没有限制，因此只需正常编写HTML即可。
- 缺点就是速度较慢，因为每个区域都必须进行复制

注: 收集多个场景的特有元素于某个对象中, 然后在render函数逐个处理每个场景

## 拾取
推断用户点击或触碰了哪个对象的过程。

* 射线追踪法[case4_6]
从鼠标处发射一条射线，穿透场景的视椎体，通过计算，找出视锥体中哪些对象与射线相交。
> 获取鼠标的屏幕坐标.
> 其次，对其应用摄像机的投影和方向的矩阵变换，得到其在世界空间的坐标。
> 然后，计算出一条射线，从视锥体的近端平面射向远端平面。
> 再然后，对于场景中每一个对象的每一个三角，检查其是否与射线相交。

注: 假设场景中有1000个对象，每个对象有1000个三角，那么就需要检查一百万个三角。
> 优化，先检查对象的包围球或包围盒是否与射线相交，包围球或包围盒是指包含整个对象的球体或者立方体，如果射线未相交，就不需要检查组成该对象的三角们了。

问题
> 基于CPU运算的Javascript遍历每一个对象,检查其包围盒或包围球是否与射线相交，如果相交，必须遍历组成该对象的每一个三角，检查是否与射线相交。例：当对象由大量的三角组成时，这个过程会有些慢。
> 无法处理一些奇怪的着色器或者位移。例：不能对有皮肤的对象使用这种方式。
> 无法处理透明的孔洞。
因为JavaScript无法通过简单的查看纹理和材质，就推测出对象是否存在一部分是透明的或者不透明。

* 基于GPU的拾取方法[case4_6/gpu]
> 对每一个对象使用唯一的颜色进行离屏渲染。
> 然后，检查鼠标位置关联的像素的颜色。这个颜色就能告诉我们哪个对象被选中。
每个对象会被绘制两次，一次用于观看，一次用于拾取。
注: 因为拾取时只需读取1px，所以可以设置摄像机，只绘制1px，通过PerspectiveCamera.setViewOffset方法，可以告诉THREE.js计算出一个摄像机 只呈现一个大矩形的一个很小的部分。

1. 创建两个场景。一个使用正常的网格对象填充。另外一个使用“拾取材质”的网格对象填充。
2. 对于在主场景中的每一个立方体，在'拾取场景'中，同样的位置，创建一个与原立方体相似的，相关联的“可拾取立方体”、且设置唯一颜色。

## 后期处理
指应用到2d图像上的某种特效或者是滤镜。
ThreeJs工作方式:
1. 创建EffectComposer然后增加一些Pass对象。
2. 每一个Pass阶段都可以增加一些后置处理特效，添加小插图，模糊，添加光晕，添加噪点，调整色相，饱和度，对比度等等。
3. 最终把效果渲染到canvas。

* Pass
- enabled 是否使用这个pass
- needsSwap 完成这个pass后是否交换rtA和rtB
- clear 在渲染这个pass之前是否需要清除
- renderToScreen 是否将当前的内容渲染到画布上。通常来说需要在最后添加的pass设置这一项为true

* ShaderPass
一个对象，该对象的信息定义了顶点着色器，片段着色器和默认输入。将处理设置要读取的纹理以获取上一遍的结果以及要渲染到EffectComposers渲染目标之一或画布上的位置。
