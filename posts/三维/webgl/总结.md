# 绘制物体
* 设置渲染管道, 绑定数据、纹理; 在渲染管道的shader中使用数据、纹理; 绘制图像。
* 重新设置渲染管道, 才能绘制不同的物体; 相同物体多次绘制, 无需重设管道
* 绑定的数据、纹理, 渲染管道选择性的使用部分数据。

# 着色器
* 顶点着色器: 描述顶点特性, 控制点的位置和大小。
* 片元着色器: 进行逐片元处理过程的程序, 控制点的颜色。
* 片元: 显示在屏幕上的一个像素(包括位置、颜色和其他信息)

顶点着色器处理完成 -> 图形装配 -> 光栅化 -> 逐片元调用片元着色器

[光栅化]
将矢量的几何图形转变为栅格化的片元(像素)。
生成的片元带有坐标信息, 调用片元着色器也会携带这些信息。

* 坐标系
- canvas自身坐标系 左上角 为原点; x右正、y下正
- webgl坐标系 中心 为原点, 范围为 [-1, 1]
- 纹理坐标系 左下角 为原点, 范围 [0, 1]; x右正、y上正
  - 注: 图片为像素是从左往右、从上往下排列的

* 纹理
- 激活纹理单元, 将纹理对象和纹理单元绑定; 指定纹理对象的属性
- 片元着色器的采样器 绑定 指定的纹理单元。

* 3D坐标系
多个着色器 必须先指定着色器、才能设置对应的 Uniform变量; 必须指定 使用的数据缓冲对象。

* 标准化
在每次顶点着色器运行后，可见的所有顶点都为标准化设备坐标。也就是说，每个顶点的x，y，z坐标都应该在-1.0到1.0之间，超出这个坐标范围的顶点都将不可见。我们通常会自己设定一个坐标的范围，之后再在顶点着色器中将这些坐标变换为标准化设备坐标。

* 世界坐标移动
V<world> = M<translate> ⋅ M<rotate> ⋅ M<scale> ⋅ V<local>

# 三维物体
三维物体是由二维图形组成的; 但是三维物体需要考虑到 深度信息(Z轴) [-1, 1]

* 视点、观察目标点和上方向
视点: 观察者所处的位置。观察目标点: 观察目标所在的点。两者确定视线(从视点出发，穿过观察目标点并继续延伸)
上方向: 把观察到的景象绘制到屏幕上[头部偏移会导致观察到的场景也偏移]

视图矩阵: 根据视点、观察点、上方向创建视图矩阵。

* 可视范围
视角在极左或极右, 三角形会缺少一角; 没有显示设定可视空间, 而默认可视深度不够远。
- webgl只显示可视范围内的区域；不绘制可视范围外的对象, 是降低程序开销的基本手段。
- 水平视角、垂直视角、可视深度, 定义了可视空间。

* 投影矩阵(裁剪矩阵)
将指定范围内的坐标变换为标准化设备坐标的范围(-1.0, 1.0)
near/far 是近/远裁面相对于视点的距离

* 盒状空间 长方体可视空间, 由正射投影产生
左右/上下/近远 裁面

* 裁剪空间坐标
V<clip> = M<projection> ⋅ M<view> ⋅ M<model> ⋅ V<local>

# 深度测试
在默认情况下按照坐标点的顺序绘制图形, 且后绘制的图形覆盖先绘制的图形(高校)。

消除被遮挡的表面, 不必顾及缓冲区中的顺序(远处的物体会自动被近处的物体遮挡住, 不会绘制出来)

- 多边形偏移 解决深度冲突(两个表面过于接近, 但是深度缓冲区有限的精度无法区分前后了)

# 光照

* 颜色
现实生活中看到某一物体的颜色并不是这个物体真正拥有的颜色，而是它所反射的(Reflected)颜色。
物体的颜色: 物体从一个光源反射各个颜色分量的大小。

## 基础光照 7-1
冯氏光照模型
1. 环境光照(Ambient Lighting)：使用一个环境光照常量，永远会给物体一些颜色。
<环境光> = <光颜色> x <表面色> x 强度
2. 漫反射光照(Diffuse Lighting)：模拟光源对物体的方向性影响。物体的某一部分越是正对着光源，它就会越亮。
<漫反射光> = <入射光颜色> x <表面色> x cosθ
3. 镜面光照(Specular Lighting)：模拟有光泽物体上面出现的亮点。镜面光照的颜色相比于物体的颜色会更倾向于光的颜色。

* 法线
表面的朝向; 每个表面都有两个面(正、背面), 两个面各自有一个法向量。
按照 v0-v1-v2-v3的顺序绘制一个平面, 从正面观察这个表面时 => 四个顶点顺时针; 从背面观察这个表面时 => 四个顶点逆时针。
计算运动后的法向量: 用法向量乘以模型矩阵的逆转置矩阵。

* 计算入射角
cosθ = <光线方向> · <法线方向>
方向必须 归一化, 将一个矢量的长度调整为1, 同时保持方向不变的过程。
光线方向 实际是 入射方向的反方向。

* 镜面光照
决定于光的方向和物体的法向量，也决定于观察方向；反射向量与观察方向的角度差，它们之间夹角越小，镜面光的作用就越大。
例如: 一面镜子，镜面光照最强的地方就是我们看到表面上反射光的地方。
[]("./assets/镜面光照.png")

## 材质 7-2
在现实世界里，每个物体会对光产生不同的反应; 模拟多种类型的物体，就必须针对每种表面定义不同的材质属性。

物体视觉输出: 由物体和光的颜色、并结合环境光与镜面强度分量共同决定。

比如树叶的漫反射率(0.54, 0.89, 0.63), 可以这么理解，
树叶可以反射光照中: 54%的红色光，89%的绿色光，63%的蓝色光，
树叶可以吸收光照中: 1-54%的红色光，1-89%的绿色光，1-63%的蓝色光

```c++
// p_l.fs demo1
// 创建结构体来储存物体的材质属性; 提前计算好了这种材质在光照下的表现(代替物体原色)
// 不同物体对光照的表现不一样, 材质就是对这些表现的数据化

struct Material {
  vec3 ambient;   // 在环境光照下表面反射的颜色，通常与表面的颜色相同。
  vec3 diffuse;   // 在漫反射光照下表面的颜色，期望的物体颜色
  vec3 specular;  // 表面上镜面高光的颜色
  float shininess;// 镜面高光的散射/半径
};
uniform Material material;
```

此时物体太亮了: 原因是环境光、漫反射和镜面光这三个颜色对任何一个光源都全力反射。
```c++
// p_l_2.fs demo2
// 光源对环境光、漫反射和镜面光分量也分别具有不同的强度。

struct Light {
  vec3 position;
  vec3 ambient;
  vec3 diffuse;
  vec3 specular;
};
uniform Light light;
```

## 贴图 7-3
一张覆盖物体的图像，能够逐片段索引其独立的颜色值。

* 漫反射贴图
```c++
// 用纹理贴图中的像素点值 代表材质中的漫反射(率)
// p_l.fs
struct Material {
  sampler2D diffuse; // 漫反射贴图(环境光取相同色)
  vec3 specular;
  float shininess;
};
```

* 镜面光贴图
```c++
// 例子中 物体大部分都是木头，不应该有这么强的镜面高光的; 
// 使用一个专门用于镜面高光的纹理贴图, 其中的每个像素点 代表材质中的镜面高光(率)

// p_l_2.fs
struct Material {
  sampler2D diffuse;
  sampler2D specular; // 镜面光贴图
  float shininess;
};
```
* 放射光贴图
```c++
// 一个储存了每个片段的发光值的贴图(与当前光照无关)
// 发光值: 一个包含（假设）光源的物体发光时可能显现的颜色，这样的话物体就能够忽略光照条件进行发光。

// p_l_3.fs
struct Material {
  sampler2D diffuse;
  sampler2D specular;
  sampler2D emissive; // 放射光贴图
  float shininess;
};
```

## 投光物 7-4
将光投射(Cast)到物体的光源叫做投光物.

* 平行光
称为定向光: 一个假设光源处于无限远处的模型, 它的所有光线都有着相同的方向，与光源的位置是没有关系的。
```c++
// p_l.fs
struct Light {
  vec3 direction; // 平行光方向, 所有片段的光照方向一致
  vec3 ambient;
  vec3 diffuse;
  vec3 specular;
};
```

* 点光源
处于世界中某一个位置的光源，会朝着所有方向发光，但光线会随着距离逐渐衰减。
```c++
// 7-1、7-2、7-3 都是以点光源为例子
struct Light {
  vec3 position; // 点光源位置, 计算光照方向
  vec3 ambient;
  vec3 diffuse;
  vec3 specular;
};
```

* 衰减
在现实世界中，灯在近处通常会非常亮，但随着距离的增加光源的亮度一开始会下降非常快，但在远处时剩余的光强度就会下降的非常缓慢了。
[]('./assets/光照/光照衰减.png')
```c++
// p_l_2.fs
struct Light {
  vec3 position;
  vec3 ambient;
  vec3 diffuse;
  vec3 specular;

  // 关照衰减
  float constant;
  float linear;
  float quadratic;
};

// 衰减系统公式
float distance = length(light.position - v_pos);
float attenuation = 1.0f / (light.constant + light.linear * distance + light.quadratic * (distance * distance));
```

* 聚光
位于环境中某个位置的光源，只朝一个特定方向而不是所有方向照射光线; 只有在聚光方向的特定半径内的物体才会被照亮，其它的物体都会保持黑暗。聚光很好的例子就是路灯或手电筒。[p_l_3.fs]

手电筒是一个位于观察者位置的聚光，通常它都会瞄准玩家视角的正前方。基本上说，手电筒就是普通的聚光，但它的位置和方向会随着玩家的位置和朝向不断更新。【手电筒和相机同步】

[平滑/软化边缘]('./assets/光照/聚光-软化.png') [p_l_4.fs]

## 多光源 7-5
创建一个包含六个光源的场景; 模拟一个类似太阳的定向光(Directional Light)光源，四个分散在场景中的点光源(Point Light)，以及一个手电筒(Flashlight)。

# 模型

3D建模工具: 使用一种叫做UV映射(uv-mapping)的手段来应用贴图。这些工具将会在导出到模型文件的时候自动生成所有的顶点坐标、顶点法线以及纹理坐标。

## Assimp
https://github.com/kovacsv/assimpjs 【加载数据有问题❌】

## 网格
一个网格至少需要一系列的顶点，每个顶点包含一个位置向量、一个法向量和一个纹理坐标向量。
一个网格应该包含用于索引绘制的索引以及纹理形式的材质数据（漫反射/镜面光贴图）。

# 高级

片段着色器 -> 模板测试 -> 深度测试

## 深度测试
注: 屏幕空间坐标可以直接使用GLSL内建变量gl_FragCoord从片段着色器中直接访问, 它的x和y分量代表了片段的屏幕空间坐标（其中(0, 0)位于左下角）, z分量是片段真正的深度值。

* depthFunc
测试失败, 片段将会直接丢弃、不会更新深度缓冲; 测试成功, 更新深度缓冲;
[]('./assets/深度测试函数.png')

* 深度值精度
深度缓冲包含了一个介于0.0和1.0之间的深度值。
[]('./assets/深度值精度.png')

* 防止深度冲突
1. 最重要的技巧是永远不要把多个物体摆得太靠近，以至于它们的一些三角形会重叠。
2. 尽可能将近平面设置远一些。
3. 使用更高精度的深度缓冲。

## 模板测试
模板缓冲（通常）每个模板值是8位的, 因此每个像素/片段一共能有256种不同的模板值; 可以将这些模板值设置为想要的值，然后当某一个片段有某一个模板值的时候，就可以选择丢弃或是保留这个片段了。
[]('./assets/模板测试.png')

* 步骤如下：
1. 启用模板缓冲的写入。
2. 渲染物体，更新模板缓冲的内容。
3. 禁用模板缓冲的写入。
4. 渲染（其它）物体，根据模板缓冲的内容丢弃特定的片段。
注: 可以根据场景中已绘制的其它物体的片段，来决定是否丢弃特定的片段

* glStencilMask
允许设置一个位掩码(Bitmask)，它会与将要写入缓冲的模板值进行与(AND)运算。
默认值为0xFF, 设置的位掩码所有位都为1，不影响输出; 但如果将它设置为0x00，写入缓冲的所有模板值最后都会变成0(与深度测试中的glDepthMask(GL_FALSE)是等价的)

* glStencilFunc
决定片段取舍。
如果测试失败了,片段将会被丢弃；如果测试通过了, 模板缓冲更新与否、取决于op函数。
[]('./assets/模板函数Func.png')

* glStencilOp
决定如何更新缓冲。
片段测试通过、失败, 都可能更新缓冲(要按照op函数设置决定)
[]('./assets/模板函数Op.png')

### 物体轮廓
1. 绘制物体前, 设置模板函数为gl.ALWAYS，当物体片段被渲染时，将模板缓冲更新为1。
2. 禁用模板写入、深度测试(开启、关闭的差异)。
3. 缩放物体、使用单色着色器绘制边框颜色。
4. 只在模板值不等于1的片段才绘制(放大区间片段)。
5. 重置模板测试策略。

## 混合
混合: 实现物体透明度的一种技术。
透明: 一个物体（或者其中的一部分）不是纯色的，它的颜色是物体本身的颜色和它背后其它物体的颜色的不同强度结合。

### 丢弃片段
纹理颜色的alpha值是否低于0.1的阈值，如果是的话，则丢弃这个片段。片段着色器保证了它只会渲染不是（几乎）完全透明的片段。
虽然直接丢弃片段很好，但它不能让我们渲染半透明的图像; 

### 混合
要想渲染有多个透明度级别的图像，我们需要启用混合(Blending)。

* 启用混合
片段着色器运行完成、并且所有的测试都通过之后; '混合方程' 才会应用到片段颜色输出与当前颜色缓冲中的值上。
[]('./assets/混合方程.png')
源颜色和目标颜色将会由自动设定，但源因子和目标因子的值可以由我们来决定。

* glBlendFunc
该函数用来 设置源和目标因子。


# 参考文献

## 四元数
- [四元数与3D旋转](https://krasjet.github.io/quaternion/quaternion.pdf)
- [四元数的视频系列](https://www.youtube.com/watch?v=d4EgbgTm0Bg)
- [万向节死锁](https://krasjet.github.io/quaternion/bonus_gimbal_lock.pdf)
- [材质属性](http://devernay.free.fr/cours/opengl/materials.html)
