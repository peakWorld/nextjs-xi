* 三角形正反面  [case4_1/cube <set3DCube|set3DCubeRight>]

WebGL中三角形的正反面, **正面三角形的顶点顺序是逆时针方向，反面三角形是顺时针方向**
[]('./assets/三角形正反面.png')

```ts
// 默认“剔除<不用绘制>”背面三角形
gl.enable(gl.CULL_FACE)
```
对于WebGL而言，一个三角形是顺时针还是逆时针是根据裁剪空间中的顶点顺序判断的; 换句话说，WebGL是根据在顶点着色器中运算后提供的结果来判定的，因为通常情况下只需要看到 正面对的面。

* 深度缓冲
一个存储像素深度的矩形。一个深度像素对应一个着色像素，在绘制图像时组合使用。

当WebGL绘制每个着色像素时也会写入深度像素，它的值基于顶点着色器返回的Z值<(-1 到 +1)> ，这个值会被转换到深度空间( 0 到 +1)。
默认情况: WebGL绘制一个着色像素之前会检查对应的深度像素，如果对应的深度像素中的深度值小于当前像素的深度值，WebGL就不会绘制新的颜色。 反之它会绘制片断着色器提供的新颜色并更新深度像素中的深度值。这也意味着在其他像素后面的像素不会被绘制。
```ts
gl.enable(gl.DEPTH_TEST)
```

## 正射投影 [case4_1]

* 投影矩阵<非正式的正射｜透视投影矩阵>
将像素转换为符合裁剪空间范围的坐标。
- 注: [基础/投影矩阵<平面2D>]
```ts
const getProjection = function (width: number, height: number, depth: number){
  return [
    2 / width, 0,           0,         0,
    0,         -2 / height, 0,         0,
    0,         0,           2 / depth, 0,
    -1,        1,           0,         1
  ];
};
```

* 绘制立体F[case4_1/cube]

* 正射(投影)矩阵
```ts
function orthographic (left, right, bottom, top, near, far) {
  return [
    2 / (right - left), 0, 0, 0,
    0, 2 / (top - bottom), 0, 0,
    0, 0, 2 / (near - far), 0,

    (left + right) / (left - right),
    (bottom + top) / (bottom - top),
    (near + far) / (near - far),
    1,
  ];
}
```

## 透视投影
离得越远显得越小。

* 模拟实现远小近大的效果 [case4_2]
简单的做法就是将裁减空间中的X和Y值除以Z值。
随着Z变大距离就变远了，画的也会小一点。如果除以裁剪空间中的Z值可能会变大，因为Z是一个较小的值(-1到+1)。但是可以提供一个fudgeFactor因子和Z相乘，这样就可以调整缩放的程度。

注: 事实上WebGL会将提供给gl_Position的 x,y,z,w 值自动除以 w。[case4_2/vs.glsl]

```c++
// z值缩放<0~2.0>
float zToDivideBy = 1.0f + position.z * u_fudgeFactor;

// webgl自动除以w值
gl_Position = vec4(position.xyz, zToDivideBy);
```

矩阵实现<列主序>
```ts
function makeZToWMatrix(fudgeFactor) {
  return [
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, fudgeFactor,
    0, 0, 0, 1,
  ];
}
```

- 问题，将Z值设置为-100左右的时候，‘F’提前消失了。
正常的三维空间坐标系符合‘右手定则’, Z轴正方向指向屏幕外。
在裁剪空间 Z近裁面-1/Z远裁面1;

> 此处为了使像素经过处理后符合裁剪空间Z轴范围, 才设置Z负值向屏幕外。
此时是投影矩阵<其视窗的深度为400>，经过函数getProjection处理得值为 -1/2；
再模拟实现远小近大, 经过函数makeZToWMatrix处理得值为 -1;
而裁剪空间Z轴范围为-1～1; 所以会提前消失。

* 透视(投影)矩阵
```ts
function perspective (fieldOfViewInRadians, aspect, near, far) {
  var f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewInRadians);
  var rangeInv = 1.0 / (near - far);

  return [
    f / aspect, 0, 0,                         0,
    0,          f, 0,                         0,
    0,          0, (near + far) * rangeInv,  -1,
    0,          0, near * far * rangeInv * 2, 0
  ];
}

// 某个点 经过透视矩阵处理后, 对应的裁剪空间坐标
v.x = f / aspect * p.x
v.y = f * p.y
v.z = (near + far) * rangeInv * p.z + near * far * rangeInv * 2 * p.w
v.w = -z
```

- 矩阵假定观察位置为 0,0,0 并且看向 Z 轴负方向， Y 轴为上方向。

