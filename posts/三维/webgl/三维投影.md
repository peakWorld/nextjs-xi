* 三角形正反面  [case4_1/cube <set3DCube|set3DCubeRight>]

WebGL中三角形的正反面, **正面三角形的顶点顺序是逆时针方向，反面三角形是顺时针方向**
[]('./assets/三角形正反面.png')

```ts
// 默认“剔除<不用绘制>”背面三角形
gl.enable(gl.CULL_FACE)
```
对于WebGL而言，一个三角形是顺时针还是逆时针是根据裁剪空间中的顶点顺序判断的; 换句话说，WebGL是根据在顶点着色器中运算后提供的结果来判定的，因为通常情况下只需要看到 正面对的面。

* 深度缓冲
一个存储像素深度的矩形。一个深度像素对应一个着色像素，在绘制图像时组合使用。

当WebGL绘制每个着色像素时也会写入深度像素，它的值基于顶点着色器返回的Z值<(-1 到 +1)> ，这个值会被转换到深度空间( 0 到 +1)。
默认情况: WebGL绘制一个着色像素之前会检查对应的深度像素，如果对应的深度像素中的深度值小于当前像素的深度值，WebGL就不会绘制新的颜色。 反之它会绘制片断着色器提供的新颜色并更新深度像素中的深度值。这也意味着在其他像素后面的像素不会被绘制。
```ts
gl.enable(gl.DEPTH_TEST)
```

## 正射投影

* 投影矩阵 [case4_1]
将像素转换为符合裁剪空间范围的坐标。
- 注: [基础/投影矩阵<平面2D>]
```ts
const getProjection = function (width: number, height: number, depth: number){
  return [
    2 / width, 0,           0,         0,
    0,         -2 / height, 0,         0,
    0,         0,           2 / depth, 0,
    -1,        1,           0,         1
  ];
};
```

* 绘制立体F[case4_1/cube]

* 正射(投影)矩阵
```ts
function orthographic (left, right, bottom, top, near, far) {
  return [
    2 / (right - left),              0,                               0,                           0,
    0,                               2 / (top - bottom),              0,                           0,
    0,                               0,                               2 / (near - far),            0,
    (left + right) / (left - right), (bottom + top) / (bottom - top), (near + far) / (near - far), 1,
  ];
}
// 某个点 经过正射矩阵处理后, 对应的裁剪空间坐标
v.x = 2 / (right - left) * p.x + (left + right) / (left - right) * p.w
v.y = 2 / (top - bottom) * p.y + (bottom + top) / (bottom - top) * p.w
v.z = 2 / (near - far) * p.z + (near + far) / (near - far) * p.w
v.w = p.w
```

## 透视投影

* 模拟实现远小近大的效果<在矩形空间, 而非视锥空间>
简单的做法就是将裁减空间中的X和Y值除以Z值。 [case4_2/divideZ]
随着Z变大距离就变远了，画的也会小一点。如果除以裁剪空间中的Z值可能会变大，因为Z是一个较小的值(-1到+1)。但是可以提供一个fudgeFactor因子和Z相乘，这样就可以调整缩放的程度。

注: 事实上WebGL会将提供给gl_Position的 x,y,z,w 值自动除以 w。[case4_2]

```c++
// z值缩放<0~2.0>
float zToDivideBy = 1.0f + position.z * u_fudgeFactor;

// webgl自动除以w值
gl_Position = vec4(position.xyz, zToDivideBy);
```

矩阵实现<列主序>
```ts
function makeZToWMatrix(fudgeFactor) {
  return [
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, fudgeFactor,
    0, 0, 0, 1,
  ];
}
```

- 问题，将Z值设置为-100左右的时候，‘F’提前消失了。
正常的三维空间坐标系符合‘右手定则’, Z轴正方向指向屏幕外。 在裁剪空间 Z近裁面-1/Z远裁面1;

> 此处为了使像素经过处理后符合裁剪空间Z轴范围, 即向屏幕外像素取负。
此时是投影矩阵<其视窗的深度为400>，经过函数getProjection处理得值为 -1/2；
再模拟实现远小近大, 经过函数makeZToWMatrix处理得值为 -1;
而裁剪空间Z轴范围为-1～1; 所以会提前消失。

* 透视(投影)矩阵<视锥空间>
```ts
function perspective (fieldOfViewInRadians, aspect, near, far) {
  var f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewInRadians);
  var rangeInv = 1.0 / (near - far);

  return [
    f / aspect, 0, 0,                         0,
    0,          f, 0,                         0,
    0,          0, (near + far) * rangeInv,  -1,
    0,          0, near * far * rangeInv * 2, 0
  ];
}

// 某个点 经过透视矩阵处理后, 对应的裁剪空间坐标
v.x = f / aspect * p.x
v.y = f * p.y
v.z = (near + far) * rangeInv * p.z + near * far * rangeInv * 2 * p.w
v.w = -z
```
- 矩阵 可以调整单位以适应裁剪空间，可以自定义视场角，选择 Z裁剪面。。
- 矩阵 将视锥中的空间转换到裁剪空间中。
- 矩阵 假定观察位置为 0,0,0 并且看向 Z 轴负方向， Y 轴为上方向

## 三维相机

* 问题, F未出现在屏幕中[4_3]
- 在之前的实践中, 是利用投影矩阵将 像素坐标 转换成 裁剪空间坐标；那么原始坐标点 符合的是像素坐标系，坐上角为原点，X轴向右为正、Y轴向下为正、Z轴向屏幕内为正。
- 而在三维相机中, 投影矩阵 符合‘右手定则'; 此时原始坐标点 符合 屏幕中间为 原点, X轴向右为正、Y轴向上为正、Z轴向屏幕外为正。

因此修改F的坐标, 使F在视锥中 => `const translation = [-150, 0, -360];`
改变旋转方向, 使F展示正确 => `const degree = [190, 40, 30];`

* 看向一个特定的F [4_3/view]

* 矩阵
- 世界矩阵<world matrix> (或者成为模型矩阵<model matrix>)
转换模型顶点到世界空间的矩阵
- 相机矩阵<camera matrix>
代表相机在世界空间中位置的矩阵。另一种说法是相机的世界矩阵。
- 视图矩阵<view matrix> [4_3/camera]
把世界空间中所有东西移到相机前。这是相机矩阵的逆。
- 投影矩阵<projection matrix>
矩阵转换视锥体空间到裁剪空间或者一些正交空间到裁剪空间。
- 本地矩阵<local matrix>
当使用场景图时，本地矩阵是是某一节点和其他节点相乘之前的矩阵。
```c++
// 着色器需要的矩阵组合
worldViewProjection = projection * view * world

// 相机矩阵求逆 即为视图矩阵
viewMatrix = inverse(cameraMatrix)

worldInverseTranpose = transpose(inverse(world))
```
